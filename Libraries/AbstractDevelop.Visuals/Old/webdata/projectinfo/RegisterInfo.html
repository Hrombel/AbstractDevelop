<head>
</head>
<body>
    <div id="title">
        <center><h1>Машина с бесконечными регистрами</h1></center>
    </div>
    <hr />
    <div id="main">
        <h2>Принцип работы</h2>
        В данной программе реализованы модели классической машины с бесконечными регистрами(далее - МБР) и её модификации - параллельной машины с бескочеными регистрами(далее - ПМБР).
        Обе вариации МБР имеют неограниченное количество пронумерованных от нуля до бесконечности регистров, способных хранить числа бесконечной длины.
        При этом, имеется доступ к любому из регистров.
        Работу МБР задет программа, имеющая ограниченную систему команд: увеличение значения любого регистра на 1, копирование значения одного регистра в
        другой, обнуление регистра, условный переход. Работа машины заканчивается, когда происходит переход к команде с несуществующим номером.
        Перечисленная система команд имеет следующий синтаксис:<br />
        <code>
<pre>
    S(n) // Увеличение значения регистра n на 1
    T(n, m) // Копирование значения регистра n в регистр m
    Z(n) // Обнуление значения регистра n
    J(n, m, k) // Условный переход. Если значения регистров m и n равны, то переход к команде с номером k.
</pre>
        </code><br />
        Работа ПМБР отличается от работы классической МБР тем, что у нее присутствует возможность параллельного выполнения заданных программ.
        То есть, в один и тот же момент времени могут выполняться разные команды. В связи с этим, система команд для МБР была расширена некоторыми
        новыми командами, такими как: запуск программы с последующим параллельным ее выполнением, запись в регистр значения с устройства ввода,
        запись значения регистра в устройство вывода, блокирование регистра с целью монопольного доступа к нему процессом-блокиратором, разблокировка
        регистра.
        Полный список команд для ПМБР имеет следующий синтаксис:<br />
        <code>
<pre>
    S(n) // Увеличение значения регистра n на 1
    T(n, m) // Копирование значения регистра n в регистр m
    Z(n) // Обнуление значения регистра n
    J(n, m, k) // Условный переход. Если значения регистров m и n равны, то переход к команде с номером k
    s(prog, n) /* Запуск программы prog в отдельном потоке и ассоциация её выполнения с регистром-индикатором n.
                    Перед началом выполнения программы регистр n обнуляется, после выполнения программы в него
                    заносится единица */
    I(n) // Запись значения с устройства ввода с последующей записью его в регистр n
    O(n) // Чтение значения регистра n и запись его в устройство вывода
    G(n) // Блокировка регистра с номером n с целью монопольного обращения к нему процессом-блокиратором
    P(n) // Разблокировка регистра с номером n и разрешение доступа к нему другим процессам
</pre>
        </code><br />
        Обявления всех команд чувствительны к регистру и должны быть записаны так, как это указано в примерах.
        Следует отметить, что поскольку в ПМБР существует возможность запускать неограниченное количество параллельно выполняющихся программ,
        то существует возможность запуска одной и той же программы большое количество раз. Всякий раз при запуске какой-либо программы создается
        процесс(поток), выполняющий описанный в ней алгоритм. Процессов, выполняющих одну и ту же программу может быть много. Поэтому не следует
        путать понятия программа и процесс. За выполнением любого созданного процесса можно следить в режиме пошагового выполнения программы.
        Кроме того, по причине неограниченности пользователя в запуске процессов, существует возможность неразумного расходования ресурсов компьютера,
        на котором выполняется эмулятор. Для выполнения каждого процесса ПМБР операционной системой выделяется отдельный поток. Поэтому,
        следует следить за тем, чтобы написанный алгоритм не зацикливался в местах запуска процессов. Чем больше создано процессов, тем дольше
        будет происходить инициированная пользователем остановка ПМБР.<br />
        Синтаксис описания программы для ПМБР отличается не только расширенной системой команд, но и некоторыми другими нововведениями, обусловленными
        иным принципом ее работы. <br />
        Поскольку появилась возможность описания нескольких программ с возможностью их параллельного запуска, введены понятия блок программы и точка входа.
        Блок программы - это синтаксическая конструкция, состоящая из объявления блока и его тела. Обявление блока содержит ключевое слово и имя программы.
        Тело блока - последовательность команд, которые составляют объявленную программу. Точка входа - это то же самое, что и блок программы, однако имеет
        другое ключевое слово и должна присутствовать в исходном тексте программы для ПМБР ровно один раз. Она необходима для однозначного определения
        программы, с которой начнется выполнение всего алгоритма для ПМБР.<br />
        Зачастую при решении тех или иных задач удобно структурировать программы по их назначению и использовать их при необходимости. Это упрощает читаемость
        кода и облегчает разработку. Поэтому, для удобства пользователя введена модульная система описания программ для ПМБР. Модуль - именованная совокупность
        программных блоков, объединенных в одно целое по их целевому назначению или иным соображениям. <br />
        Каждый модуль должен быть ровно один раз объявлен в своем файле. Причем, название модуля должно совпадать с именем файла. Пример использования
        описанных синтаксических конструкций:<br />
        <code>
<pre>
    unit Main // Объявление модуля. unit - ключевое слово, Main - название.
                
    entry main // Объявление точки входа.
    {
        I(0) // Чтение числа в регистр 0
        s(test1, 10) // Запуск программы test1 в параллельном процессе и сопоставление с ней регистра-индикатора с номером 10
        s(test2, 11) // Запуск программы test2 в параллельном процессе и сопоставление с ней регистра-индикатора с номером 11
    }
                
    program test1 // Объявление программного блока
    {
        S(0) // Инкремент регистра 0
    }
                
    program test2 
    {
        T(0, 1) // Копирование значения из регистра 0 в 1
        S(1) // Инкремент значения в регистре 1
    }
</pre>
        </code><br />
        В данном примере показан запуск программ, находящихся в пределах одного модуля. Обращение к программе, находящейся в другом модуле, продемонстрирован на
        примере ниже. Предположим, что мы имеем два модуля: Main и Math. В программе test модуля Main описана команда, запускающая процесс выполнения
        программы, находящейся в модуле Math:<br />
        <code>
<pre>
    program test
    {
        S(0)
        s(Math.Add, 5)
    }
</pre>
        </code><br />
        Следует отметить, что чтение и запись данных - "дорогостоящие" в плане производительности операции, поскольку они выполняются не в процессе, вызвавшем
        их, а в процессе эмулятора, занимающемся отображением пользовательского интерфейса. То есть, при выполнении таких операций вызывающий процесс ожидает,
        пока отработает основной процесс. Если при вводе данных это некритично, то при частом выводе данных производительность мыполняемой на ПМБР программы
        может упасть. Кроме того, зацикленный ввод/вывод информации может создать неприятную ситуацию, когда всплывающие окна или постоянный вывод в окно
        отладки будут блокировать пользовательский ввод.<br />
    </div>
    <hr />
</body>